
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>controllers: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">cat-voting-app/controllers/cat_controller.go (73.4%)</option>
				
				<option value="file1">cat-voting-app/controllers/default.go (100.0%)</option>
				
				<option value="file2">cat-voting-app/main.go (0.0%)</option>
				
				<option value="file3">cat-voting-app/routers/router.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package controllers

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "sync"
        "time"

        "github.com/beego/beego/v2/server/web"
)

// CatController handles API requests
type CatController struct {
        web.Controller
        HTTPClient *http.Client
}

// Structs to unmarshal Cat API responses
type CatImage struct {
        ID     string `json:"id"`
        URL    string `json:"url"`
        Width  int    `json:"width"`
        Height int    `json:"height"`
}

type FavouriteRequest struct {
        ImageID string `json:"image_id"`
        SubID   string `json:"sub_id"`
}

// FetchCatImages handles the request to fetch random cat images
func (c *CatController) FetchCatImages() <span class="cov8" title="1">{
        if c.Data == nil </span><span class="cov0" title="0">{
                c.Data = make(map[interface{}]interface{})
        }</span>
        <span class="cov8" title="1">baseURL, err := web.AppConfig.String("catapi_base_url")
        if err != nil </span><span class="cov0" title="0">{
                c.Ctx.Output.SetStatus(500)
                c.Ctx.WriteString("Failed to load Cat API base URL from config")
                return
        }</span>

        <span class="cov8" title="1">apiKey, err := web.AppConfig.String("catapi_key")
        if err != nil </span><span class="cov0" title="0">{
                c.Ctx.Output.SetStatus(500)
                c.Ctx.WriteString("Failed to load Cat API key from config")
                return
        }</span>

        // Get the breed_id from the request
        <span class="cov8" title="1">breedID := c.GetString("breed_id")

        // Fetch images using the helper function
        images, err := fetchCatImages(baseURL, apiKey, breedID)
        if err != nil </span><span class="cov0" title="0">{
                c.Ctx.Output.SetStatus(500)
                c.Data["json"] = map[string]string{"error": err.Error()}
                c.ServeJSON()
                return
        }</span>

        // Return the fetched images as JSON
        <span class="cov8" title="1">c.Data["json"] = images
        c.ServeJSON()</span>
}

// FetchBreeds handles the request to fetch all cat breeds
func (c *CatController) FetchBreeds() <span class="cov8" title="1">{
        baseURL, err := web.AppConfig.String("catapi_base_url")
        if err != nil </span><span class="cov0" title="0">{
                c.Ctx.Output.SetStatus(500)
                c.Ctx.WriteString("Failed to load API base URL from config")
                return
        }</span>

        <span class="cov8" title="1">apiKey, err := web.AppConfig.String("catapi_key")
        if err != nil </span><span class="cov0" title="0">{
                c.Ctx.Output.SetStatus(500)
                c.Ctx.WriteString("Failed to load API key from config")
                return
        }</span>

        <span class="cov8" title="1">client := &amp;http.Client{Timeout: 10 * time.Second}
        req, err := http.NewRequest("GET", baseURL+"/breeds", nil)
        if err != nil </span><span class="cov0" title="0">{
                c.Ctx.Output.SetStatus(500)
                c.Ctx.WriteString("Failed to create request")
                return
        }</span>

        <span class="cov8" title="1">req.Header.Set("x-api-key", apiKey)

        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                c.Ctx.Output.SetStatus(500)
                c.Ctx.WriteString("Failed to fetch breeds")
                return
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        var breeds []map[string]interface{}
        if err := json.NewDecoder(resp.Body).Decode(&amp;breeds); err != nil </span><span class="cov0" title="0">{
                c.Ctx.Output.SetStatus(500)
                c.Ctx.WriteString("Failed to parse response")
                return
        }</span>

        <span class="cov8" title="1">c.Data["json"] = breeds
        c.ServeJSON()</span>
}

// func (c *CatController) FetchBreeds() {
//         baseURL, err := web.AppConfig.String("catapi_base_url")
//         if err != nil {
//                 c.Ctx.Output.SetStatus(500)
//                 c.Ctx.WriteString("Failed to load API base URL from config")
//                 return
//         }

//         apiKey, err := web.AppConfig.String("catapi_key")
//         if err != nil {
//                 c.Ctx.Output.SetStatus(500)
//                 c.Ctx.WriteString("Failed to load API key from config")
//                 return
//         }

//         // Channels for concurrency
//         breedsChan := make(chan []map[string]interface{})
//         imagesChan := make(chan []map[string]interface{})
//         errorChan := make(chan error, 2)

//         fmt.Println("Mark 1")

//         // WaitGroup for goroutines
//         var wg sync.WaitGroup

//         // Task 1: Fetch Breeds
//         wg.Add(1)
//         go func() {
//                 defer wg.Done()
//                 fmt.Println("Fetching breeds started...")
//                 client := &amp;http.Client{Timeout: 10 * time.Second}
//                 req, err := http.NewRequest("GET", baseURL+"/breeds", nil)
//                 if err != nil {
//                         errorChan &lt;- fmt.Errorf("Failed to create breeds request: %w", err)
//                         return
//                 }
//                 req.Header.Set("x-api-key", apiKey)

//                 resp, err := client.Do(req)
//                 if err != nil {
//                         errorChan &lt;- fmt.Errorf("Failed to fetch breeds: %w", err)
//                         return
//                 }
//                 defer resp.Body.Close()

//                 var breeds []map[string]interface{}
//                 if err := json.NewDecoder(resp.Body).Decode(&amp;breeds); err != nil {
//                         errorChan &lt;- fmt.Errorf("Failed to parse breeds response: %w", err)
//                         return
//                 }

//                 if len(breeds) &gt; 0 {
//                         breedsChan &lt;- breeds // Send to channel
//                         fmt.Println("Number of breeds sent:", len(breeds))
//                 } else {
//                         errorChan &lt;- fmt.Errorf("No breeds available")
//                 }
//         }()

//         fmt.Println("Mark 2")

//         // Task 2: Fetch Images for First Breed
//         wg.Add(1)
//         go func() {
//                 time.Sleep(5 * time.Second)
//                 defer wg.Done()

//                 fmt.Println("Waiting for breeds...")

//                 var breeds []map[string]interface{}
//                 select {
//                 case b := &lt;-breedsChan:
//                         breeds = b
//                         fmt.Println("Breeds fetched in Task 2:", len(breeds))
//                 case err := &lt;-errorChan:
//                         fmt.Println("Error while waiting for breeds:", err)
//                         errorChan &lt;- err // Forward error
//                         return
//                 }

//                 fmt.Println("Breeds fetched:", len(breeds))

//                 if len(breeds) == 0 {
//                         errorChan &lt;- fmt.Errorf("No breeds available")
//                         return
//                 }

//                 // Fetch images for the first breed
//                 breedID, ok := breeds[0]["id"].(string)
//                 if !ok {
//                         errorChan &lt;- fmt.Errorf("Invalid breed ID format")
//                         return
//                 }

//                 fmt.Println("Fetching images for breed ID:", breedID)

//                 client := &amp;http.Client{Timeout: 10 * time.Second}
//                 req, err := http.NewRequest("GET", fmt.Sprintf("%s/images/search?breed_id=%s", baseURL, breedID), nil)
//                 if err != nil {
//                         errorChan &lt;- fmt.Errorf("Failed to create images request: %w", err)
//                         return
//                 }
//                 req.Header.Set("x-api-key", apiKey)

//                 resp, err := client.Do(req)
//                 if err != nil {
//                         errorChan &lt;- fmt.Errorf("Failed to fetch images: %w", err)
//                         return
//                 }
//                 defer resp.Body.Close()

//                 var images []map[string]interface{}
//                 if err := json.NewDecoder(resp.Body).Decode(&amp;images); err != nil {
//                         errorChan &lt;- fmt.Errorf("Failed to parse images response: %w", err)
//                         return
//                 }

//                 if len(images) &gt; 0 {
//                         imagesChan &lt;- images // Send data to channel
//                         fmt.Println("Images for first breed fetched successfully")
//                 } else {
//                         errorChan &lt;- fmt.Errorf("No images available")
//                 }
//         }()

//         fmt.Println("Mark 4")

//         // Close channels after tasks complete
//         go func() {
//                 wg.Wait()
//                 close(breedsChan)
//                 close(imagesChan)
//                 close(errorChan)
//         }()

//         // Aggregate results
//         var breeds []map[string]interface{}
//         var images []map[string]interface{}
//         var errors []error

//         fmt.Println("Mark 5")

//         for {
//                 select {
//                 case b, ok := &lt;-breedsChan:
//                         if ok {
//                                 breeds = b
//                                 fmt.Println("Breeds received:", len(breeds))
//                         } else {
//                                 fmt.Println("breedsChan closed")
//                                 breedsChan = nil
//                         }
//                 case i, ok := &lt;-imagesChan:
//                         if ok {
//                                 images = i
//                                 fmt.Println("Images received:", len(images))
//                         } else {
//                                 fmt.Println("imagesChan closed")
//                                 imagesChan = nil
//                         }
//                 case err, ok := &lt;-errorChan:
//                         if ok {
//                                 errors = append(errors, err)
//                                 fmt.Println("Error occurred:", err)
//                         } else {
//                                 fmt.Println("errorChan closed")
//                                 errorChan = nil
//                         }
//                 }

//                 // Break when all channels are closed
//                 if breedsChan == nil &amp;&amp; imagesChan == nil &amp;&amp; errorChan == nil {
//                         break
//                 }
//         }

//         fmt.Println("Mark 6")

//         // Handle errors
//         if len(errors) &gt; 0 {
//                 c.Ctx.Output.SetStatus(500)
//                 c.Data["json"] = map[string]interface{}{
//                         "error":   "Failed to fetch data",
//                         "details": errors,
//                 }
//                 c.ServeJSON()
//                 return
//         }

//         fmt.Println("Mark 7")

//         // Return breeds and first breed images
//         c.Data["json"] = map[string]interface{}{
//                 "breeds": breeds,
//                 "images": images,
//         }
//         c.ServeJSON()
// }

func (c *CatController) AddToFavourites() <span class="cov8" title="1">{
        if c.Data == nil </span><span class="cov8" title="1">{
                c.Data = make(map[interface{}]interface{})
        }</span>

        <span class="cov8" title="1">baseURL, _ := web.AppConfig.String("catapi_base_url")
        apiKey, _ := web.AppConfig.String("catapi_key")

        // Read the raw body
        rawBody, err := io.ReadAll(c.Ctx.Request.Body)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Println("Error reading request body:", err)
                if c.Data == nil </span><span class="cov0" title="0">{
                        c.Data = make(map[interface{}]interface{}) // Initialize if nil
                }</span>
                <span class="cov8" title="1">c.Ctx.Output.SetStatus(400)
                c.Data["json"] = map[string]string{"error": "Failed to read request body"}
                c.ServeJSON()
                return</span>
        }
        <span class="cov8" title="1">fmt.Println("Raw request body:", string(rawBody)) // Log the raw request body for debugging

        // Parse the request body into a struct
        var reqBody struct {
                ImageID string `json:"image_id"`
                SubID   string `json:"sub_id"`
        }
        if err := json.Unmarshal(rawBody, &amp;reqBody); err != nil </span><span class="cov8" title="1">{
                fmt.Println("Error unmarshalling JSON:", err)
                c.Ctx.Output.SetStatus(400)
                c.Data["json"] = map[string]string{"error": "Invalid JSON format"}
                c.ServeJSON()
                return
        }</span>
        <span class="cov8" title="1">fmt.Println("Parsed request body:", reqBody)

        // Channels to handle tasks
        addToFavoritesChan := make(chan error, 1)             // Buffered channel to avoid blocking
        nextImageChan := make(chan map[string]interface{}, 1) // Buffered channel
        errorChan := make(chan error, 2)                      // Buffered channel

        // WaitGroup to manage goroutines
        var wg sync.WaitGroup

        // Task 1: Add image to favorites
        wg.Add(1)
        go func() </span><span class="cov8" title="1">{
                defer wg.Done()
                err := addToFavorites(baseURL, apiKey, reqBody.ImageID, reqBody.SubID)
                addToFavoritesChan &lt;- err // Send result to channel
        }</span>()

        // Task 2: Fetch the next image
        <span class="cov8" title="1">wg.Add(1)
        go func() </span><span class="cov8" title="1">{
                defer wg.Done()
                images, err := fetchCatImages(baseURL, apiKey, "")
                if err != nil </span><span class="cov0" title="0">{
                        errorChan &lt;- err
                        return
                }</span>
                <span class="cov8" title="1">if len(images) &gt; 0 </span><span class="cov8" title="1">{
                        nextImageChan &lt;- images[0] // Send the first image to the channel
                }</span> else<span class="cov0" title="0"> {
                        errorChan &lt;- fmt.Errorf("No images available")
                }</span>
        }()

        // Close channels after all goroutines are done
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                wg.Wait()
                close(addToFavoritesChan)
                close(nextImageChan)
                close(errorChan)
        }</span>()

        // Aggregate results
        <span class="cov8" title="1">var addToFavoritesErr error
        var nextImage map[string]interface{}
        var errors []error

        for </span><span class="cov8" title="1">{
                select </span>{
                case err, ok := &lt;-addToFavoritesChan:<span class="cov8" title="1">
                        if ok </span><span class="cov8" title="1">{
                                addToFavoritesErr = err
                        }</span> else<span class="cov8" title="1"> {
                                addToFavoritesChan = nil
                        }</span>
                case img, ok := &lt;-nextImageChan:<span class="cov8" title="1">
                        if ok </span><span class="cov8" title="1">{
                                nextImage = img
                        }</span> else<span class="cov8" title="1"> {
                                nextImageChan = nil
                        }</span>
                case err, ok := &lt;-errorChan:<span class="cov8" title="1">
                        if ok </span><span class="cov0" title="0">{
                                errors = append(errors, err)
                        }</span> else<span class="cov8" title="1"> {
                                errorChan = nil
                        }</span>
                }

                // Break when all channels are closed
                <span class="cov8" title="1">if addToFavoritesChan == nil &amp;&amp; nextImageChan == nil &amp;&amp; errorChan == nil </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">fmt.Println("Mark!:", nextImage)

        // Handle errors
        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                c.Ctx.Output.SetStatus(500)
                c.Data["json"] = map[string]interface{}{
                        "error":   "Failed to complete tasks",
                        "details": errors,
                }
                c.ServeJSON()
                return
        }</span>

        // Return success with the next image
        <span class="cov8" title="1">c.Data["json"] = map[string]interface{}{
                "message":          "Image added to favorites and next image fetched",
                "next_image":       nextImage,
                "add_to_favorites": addToFavoritesErr == nil,
        }
        c.ServeJSON()</span>
}

func addToFavorites(baseURL, apiKey, imageID, subID string) error <span class="cov8" title="1">{
        client := &amp;http.Client{}
        payload := map[string]string{
                "image_id": imageID,
                "sub_id":   subID,
        }
        payloadBytes, _ := json.Marshal(payload)
        req, _ := http.NewRequest("POST", fmt.Sprintf("%s/favourites", baseURL), bytes.NewBuffer(payloadBytes))
        req.Header.Set("x-api-key", apiKey)
        req.Header.Set("Content-Type", "application/json")

        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Error adding to favorites: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                return fmt.Errorf("Failed to add to favorites: %s", resp.Status)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func fetchCatImages(baseURL, apiKey, breedID string) ([]map[string]interface{}, error) <span class="cov8" title="1">{
        client := &amp;http.Client{}

        // Construct the request URL
        requestURL := fmt.Sprintf("%s/images/search?limit=15", baseURL)
        if breedID != "" </span><span class="cov8" title="1">{
                requestURL += fmt.Sprintf("&amp;breed_id=%s", breedID) // Append breed_id if provided
        }</span>

        // Create the request
        <span class="cov8" title="1">req, err := http.NewRequest("GET", requestURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Failed to create request: %w", err)
        }</span>
        <span class="cov8" title="1">req.Header.Set("x-api-key", apiKey)

        // Execute the request
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Failed to fetch images: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        // Check for unexpected status codes
        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Unexpected response status: %d", resp.StatusCode)
        }</span>

        // Parse the response body
        <span class="cov8" title="1">var images []map[string]interface{}
        if err := json.NewDecoder(resp.Body).Decode(&amp;images); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Failed to decode response: %w", err)
        }</span>

        <span class="cov8" title="1">return images, nil</span>
}

func (c *CatController) GetFavourites() <span class="cov8" title="1">{
        if c.Data == nil </span><span class="cov8" title="1">{
                c.Data = make(map[interface{}]interface{})
        }</span>

        <span class="cov8" title="1">baseURL, _ := web.AppConfig.String("catapi_base_url")
        apiKey, _ := web.AppConfig.String("catapi_key")

        subID := c.GetString("sub_id") // Get user ID from query string

        requestURL := baseURL + "/favourites"
        if subID != "" </span><span class="cov8" title="1">{
                requestURL += "?sub_id=" + subID
        }</span>

        <span class="cov8" title="1">client := c.HTTPClient // Use the injected HTTP client
        if client == nil </span><span class="cov8" title="1">{
                client = &amp;http.Client{} // Fallback to default if not injected
        }</span>

        <span class="cov8" title="1">req, _ := http.NewRequest("GET", requestURL, nil)
        req.Header.Set("x-api-key", apiKey)

        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                c.Ctx.Output.SetStatus(500)
                c.Ctx.WriteString("Failed to fetch favourites")
                return
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        var favourites []map[string]interface{}
        json.NewDecoder(resp.Body).Decode(&amp;favourites)
        c.Data["json"] = favourites
        c.ServeJSON()</span>
}

func (c *CatController) RemoveFavourite() <span class="cov8" title="1">{
        baseURL, _ := web.AppConfig.String("catapi_base_url")
        apiKey, _ := web.AppConfig.String("catapi_key")

        favouriteID := c.GetString("favourite_id") // Get favourite ID from query string

        requestURL := baseURL + "/favourites/" + favouriteID

        client := &amp;http.Client{}
        req, _ := http.NewRequest("DELETE", requestURL, nil)
        req.Header.Set("x-api-key", apiKey)

        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                c.Ctx.Output.SetStatus(500)
                c.Ctx.WriteString("Failed to remove favourite")
                return
        }</span> else<span class="cov8" title="1"> {
                c.Ctx.Output.SetStatus(resp.StatusCode)
                c.Ctx.WriteString("Favourite removed successfully")
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()</span>
}

func (c *CatController) Vote() <span class="cov8" title="1">{
        if c.Data == nil </span><span class="cov8" title="1">{
                c.Data = make(map[interface{}]interface{})
        }</span>

        <span class="cov8" title="1">baseURL, _ := web.AppConfig.String("catapi_base_url")
        apiKey, _ := web.AppConfig.String("catapi_key")

        // Read and parse the request body
        rawBody, err := io.ReadAll(c.Ctx.Request.Body)
        if err != nil </span><span class="cov0" title="0">{
                c.Ctx.Output.SetStatus(400)
                c.Data["json"] = map[string]string{"error": "Failed to read request body"}
                c.ServeJSON()
                return
        }</span>

        // Channels for concurrent tasks
        <span class="cov8" title="1">voteChan := make(chan map[string]interface{})
        nextImageChan := make(chan map[string]interface{})
        errorChan := make(chan error, 2)

        // WaitGroup to manage goroutines
        var wg sync.WaitGroup

        // Task 1: Submit Vote
        wg.Add(1)
        go func() </span><span class="cov8" title="1">{
                defer wg.Done()
                result, err := submitVote(baseURL, apiKey, rawBody)
                if err != nil </span><span class="cov8" title="1">{
                        errorChan &lt;- err
                        return
                }</span>
                <span class="cov0" title="0">voteChan &lt;- result</span>
        }()

        // Task 2: Fetch Next Image
        <span class="cov8" title="1">wg.Add(1)
        go func() </span><span class="cov8" title="1">{
                defer wg.Done()
                images, err := fetchCatImages(baseURL, apiKey, "")
                if err != nil </span><span class="cov0" title="0">{
                        errorChan &lt;- err
                        return
                }</span>
                <span class="cov8" title="1">if len(images) &gt; 0 </span><span class="cov8" title="1">{
                        nextImageChan &lt;- images[0] // Send the first image to the channel
                }</span> else<span class="cov0" title="0"> {
                        errorChan &lt;- fmt.Errorf("No images available")
                }</span>
        }()

        // Close channels after tasks complete
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                wg.Wait()
                close(voteChan)
                close(nextImageChan)
                close(errorChan)
        }</span>()

        // Aggregate results
        <span class="cov8" title="1">var voteResult map[string]interface{}
        var nextImage map[string]interface{}
        var errors []error

        for </span><span class="cov8" title="1">{
                select </span>{
                case result, ok := &lt;-voteChan:<span class="cov8" title="1">
                        if ok </span><span class="cov0" title="0">{
                                voteResult = result
                        }</span> else<span class="cov8" title="1"> {
                                voteChan = nil
                        }</span>
                case image, ok := &lt;-nextImageChan:<span class="cov8" title="1">
                        if ok </span><span class="cov8" title="1">{
                                nextImage = image
                        }</span> else<span class="cov8" title="1"> {
                                nextImageChan = nil
                        }</span>
                case err, ok := &lt;-errorChan:<span class="cov8" title="1">
                        if ok </span><span class="cov8" title="1">{
                                errors = append(errors, err)
                        }</span> else<span class="cov8" title="1"> {
                                errorChan = nil
                        }</span>
                }

                // Break when all channels are closed
                <span class="cov8" title="1">if voteChan == nil &amp;&amp; nextImageChan == nil &amp;&amp; errorChan == nil </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        // Handle errors
        <span class="cov8" title="1">if len(errors) &gt; 0 </span><span class="cov8" title="1">{
                fmt.Println("Error details:", errors) // Log all errors in the slice
                for _, err := range errors </span><span class="cov8" title="1">{
                        fmt.Println("Individual error:", err) // Log individual errors
                }</span>
                <span class="cov8" title="1">c.Ctx.Output.SetStatus(500)
                c.Data["json"] = map[string]interface{}{
                        "error":   "Failed to complete tasks",
                        "details": errors,
                }
                c.ServeJSON()
                return</span>
        }

        <span class="cov0" title="0">fmt.Println("Mark 5")

        // Return success with vote result and next image
        c.Data["json"] = map[string]interface{}{
                "message":    "Vote submitted and next image fetched",
                "vote":       voteResult,
                "next_image": nextImage,
        }
        c.ServeJSON()</span>
}

func submitVote(baseURL, apiKey string, payload []byte) (map[string]interface{}, error) <span class="cov8" title="1">{
        client := &amp;http.Client{}
        req, err := http.NewRequest("POST", baseURL+"/votes", bytes.NewBuffer(payload))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create vote request: %w", err)
        }</span>
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("x-api-key", apiKey)

        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to submit vote: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        rawResponseBody, _ := io.ReadAll(resp.Body)
        fmt.Println("Raw response from The Cat API:", string(rawResponseBody))

        // Treat both 200 and 201 as successful responses
        if resp.StatusCode != http.StatusOK &amp;&amp; resp.StatusCode != http.StatusCreated </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("unexpected response status: %d, body: %s", resp.StatusCode, string(rawResponseBody))
        }</span>

        <span class="cov0" title="0">var result map[string]interface{}
        if err := json.Unmarshal(rawResponseBody, &amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse Cat API response: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("Parsed response from Cat API:", result)
        return result, nil</span>
}

func (c *CatController) GetVotes() <span class="cov8" title="1">{
        baseURL, _ := web.AppConfig.String("catapi_base_url")
        apiKey, _ := web.AppConfig.String("catapi_key")

        // Forward query parameters
        queryParams := c.Ctx.Request.URL.RawQuery

        // Create the GET request to The Cat API
        client := &amp;http.Client{}
        req, err := http.NewRequest("GET", fmt.Sprintf("%s/votes?%s", baseURL, queryParams), nil)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error creating request to Cat API:", err)
                c.Ctx.Output.SetStatus(500)
                c.Ctx.WriteString("Failed to create request")
                return
        }</span>
        <span class="cov8" title="1">req.Header.Set("x-api-key", apiKey)

        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error sending request to Cat API:", err)
                c.Ctx.Output.SetStatus(500)
                c.Ctx.WriteString("Failed to retrieve votes")
                return
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                c.Ctx.Output.SetStatus(resp.StatusCode)
                c.Ctx.WriteString("Failed to retrieve votes")
                return
        }</span>

        <span class="cov8" title="1">var result []map[string]interface{}
        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error parsing Cat API response:", err)
                c.Ctx.Output.SetStatus(500)
                c.Ctx.WriteString("Failed to parse Cat API response")
                return
        }</span>

        <span class="cov8" title="1">fmt.Println("Votes retrieved from Cat API:", result)
        c.Data["json"] = result
        c.ServeJSON()</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package controllers

import (
        beego "github.com/beego/beego/v2/server/web"
)

type MainController struct {
        beego.Controller
}

func (c *MainController) Get() <span class="cov8" title="1">{
        c.TplName = "index.tpl"
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        _ "cat-voting-app/routers"

        beego "github.com/beego/beego/v2/server/web"
)

func main() <span class="cov0" title="0">{
        beego.Run()
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package routers

import (
        "cat-voting-app/controllers"

        "github.com/beego/beego/v2/server/web"
        beego "github.com/beego/beego/v2/server/web"
)

func init() <span class="cov8" title="1">{
        beego.Router("/", &amp;controllers.MainController{})
        web.Router("/api/cats", &amp;controllers.CatController{}, "get:FetchCatImages")
        web.Router("/api/breeds", &amp;controllers.CatController{}, "get:FetchBreeds")
        web.Router("/api/add-to-favourites", &amp;controllers.CatController{}, "post:AddToFavourites")
        web.Router("/api/get-favourites", &amp;controllers.CatController{}, "get:GetFavourites")
        web.Router("/api/remove-favourite", &amp;controllers.CatController{}, "delete:RemoveFavourite")
        web.Router("/api/vote", &amp;controllers.CatController{}, "post:Vote")
        web.Router("/api/votes", &amp;controllers.CatController{}, "get:GetVotes")
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
